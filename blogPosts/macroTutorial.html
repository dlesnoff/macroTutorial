<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>macroTutorial.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.10" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
figure {
  margin: 2rem 0;
}
figcaption {
  text-align: center;
}
  
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>macroTutorial.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1 style="text-align: center;">Nim Metaprogramming - Macro Tutorial</h1>
<p>This tutorial aims to be a <em>step-by-step</em> introduction to the metaprogramming features of the Nim Language and to provide as much detail as possible to kickstart your craziest projects.
There are already many resources on the Web, but I strive to provide more thorough details on the development process and to gather them all in one place.</p>
<h3>Table of Contents:</h3>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#references-and-bibliography">References and Bibliography</a></li>
</ol>
<p><a name = "introduction"></a></p>
<h2>Introduction</h2>
<hr />
<h3>Four levels of abstraction</h3>
<p>There are four levels of abstraction in metaprogramming that are each a special kind of procedure:</p>
<ol>
<li>Ordinary procedures/iterators (No metaprogramming)</li>
<li>Generic procedures/iterators (Type level)</li>
<li>Template (Copy-paste mechanism)</li>
<li>Macro (AST substitution)</li>
</ol>
<p>It is recommended to start to program one's procedure with the lowest level of metaprogramming possible.
As more metaprogramming features are used, the compilation process takes longer and error debugging gets harder.</p>
<p>Let us start with <code>template</code>s and <code>untyped</code> parameters.
I do not present generics in this tutorial.</p>
<p>To run each snippet of code in this tutorial, you will need to import the <code>std/macros</code> package.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p><a name = "templates"></a></p>
<h2>Templates</h2>
<hr />
<p>We can see <em>templates</em> as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : <code>untyped</code>.
For those familiar with <a href="https://gcc.gnu.org/onlinedocs/cpp/">preprocessing</a> in the C family of languages (C, C++, C#), it does the same than the <code>#define</code> or <code>#if</code>, <code>#endif</code> macros and much more.</p>
<p>Nim's language defines boolean operator like <code>!=</code> with templates. You can even look at Nim's source code, that's almost the same code. See the <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">documentation</a>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Example from std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)</code></pre>
<p>We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the <code>duplicate</code> template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements
  statements

duplicate:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre class="nb-output">5
5</pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Example from Nim In Action</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
<span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
    statements

repeat <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!</pre>
<h4>Do-While keyword</h4>
<p>In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a <code>doWhile</code> construct similar to languages like <code>C</code> or <code>Javascript</code>.</p>
<p>For those only knowing Nim, this construct enables to run a loop once before testing the condition.</p>
<p>This C code always print <code>Hello World</code> at least once independantly from the start value of the variable <code>i</code>.</p>
<pre><code class="language-cpp">int i = 10;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
doWhile i &lt; <span class="hljs-number">10</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
    i.inc</code></pre><pre class="nb-output">Hello World</pre>
<p>Notice though that <em>syntaxically</em> the resulting source code is fairly different than the C++ code.</p>
<p>In the C source code, appear in this order:</p>
<ol>
<li>the <code>do</code> keyword</li>
<li>the block of instruction</li>
<li>the <code>while</code> keyword</li>
<li>the conditional (boolean expression)</li>
</ol>
<p>In Nim, we have in this order:</p>
<ol>
<li>the <code>doWhile</code> indent</li>
<li>the conditional</li>
<li>block of instruction</li>
</ol>
<p>There is no way to modify Nim's syntax as to match C's syntax.</p>
<h4>Benchmark example</h4>
<p>Another example is benchmarking code in Nim. It suffices to put our bench code inside a special block.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/[times, monotimes]
<span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = getMonoTime()
    code
    <span class="hljs-keyword">let</span> elapsed = getMonoTime() - t0
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] &quot;</span>, elapsed

benchmark <span class="hljs-string">&quot;test1&quot;</span>:
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">CPU Time [test1] 100 milliseconds, 165 microseconds, and 678 nanoseconds</pre>
<p>The code inside the <code>benchmark</code> code block will be enclosed by our template code.</p>
<p>Since the code replacement is done at compile time, this transformation does not add additional runtime to our benchmarked code.
On the contrary, a function or procedure for benchmarking would have add runtime due to the nested function calls.</p>
<p><a name = "macros"></a></p>
<h2>Macros</h2>
<hr />
<p>Template uses <code>untyped</code> parameters as lego bricks. It can not break it down into smaller pieces.
We can not check untyped parameters in a template. If our template works when given an object as argument, nothing restrics an user to give a function as argument.</p>
<p>Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
The main difference is that a template can not look inside an untyped parameter. This means that we can not check the input we get as to verify that the user did not give a function when we expect a type.</p>
<p>One can parse untyped parameters with macros. We can even act something conditionally to informations given in these parameters.
We can also inject variables into scopes.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()

throwAway:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span></code></pre>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the <code>macro</code> <code>dumpTree</code>.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<p>This output is given with the</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>We can better visualize the AST with the following picture.</p>
<figure>
<img src="./ASTtree.jpg" alt="Nim's Abstract Syntax Tree visualized with a tree">
<figcaption>Nim's Abstract Syntax Tree visualized with a tree</figcaption>
</figure>
<h3>Fireship's macro</h3>
<p>This example of macro is taken from <a href="https://www.youtube.com/watch?v=WHyOHQ_GkNo">this video</a></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>

timesTwo:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span></code></pre>
<p>This macro multiplies each integer values by two before plotting!
Let us breakdown this macro, shall we ?
To understand how a macro work, we first may look at the AST given as input.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span></code></pre>
<p>By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
</code></pre>
<p><code>StmtList</code> stands for <em>statements list</em>. It groups together all the instructions in your block.</p>
<p>The <code>Command</code> node indicates that you use a function whose name is given by its child <code>Ident</code> node. An <code>Ident</code> can be any variable, object, procedure name.</p>
<p>Our integer literal whose value is 1 has the node kind <code>IntLit</code>.</p>
<p>Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code <code>1 echo</code> which does not compile.</p>
<pre><code class="language-nim">StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
</code></pre>
<p><code>StmtList</code>, <code>Command</code>, <code>IntLit</code> and <code>Ident</code> are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix <code>nnk</code>, e.g. <code>nnkIdent</code>.
You can get the full list of node kinds <a href="https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89">at the std/macros source code</a>.</p>
<p>The output of a macro is an AST, and we can try to write it for a few examples:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Please note that line breaks are not part of the Nim's AST!</p>
<p>Here, the output AST is almost the same as the input. We only change the integer literal value.</p>
<p>Our root node in the input AST is a statement list.
To fetch the <code>Command</code> children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write <code>statements[0]</code>.
To loop over all the child nodes, one can use a <code>for statement in statements</code> loop.</p>
<p>We need to fetch the nodes under a <code>Command</code> instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to <code>nnkIntLit</code>. We get their value with the attribute <code>node.intVal</code>.</p>
<p>I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">some rules</a>.</p>
<p>It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.</p>
<p>We can pack a structure with the pragma <code>{.packed.}</code>, which removes this extra space. This has the disadvantage to slow down memory accesses.</p>
<p>We would like to detect the presence of holes in an object.</p>
<p>The first step is to look at the AST of the input code we want to parse.</p>
<p>One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
</code></pre>

<p>We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.</p>
<pre><code class="language-nim">typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
</code></pre>
<p>Type with pragmas aren't supported yet</p>
<pre><code class="language-nim">

when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
</code></pre>
<p>It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
</code></pre>
<p>Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.</p>
<p>A macro does always the same steps:</p>
<ol>
<li>Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.</li>
<li>Fetch properties of the selected node.</li>
<li>Form AST output in function of these input node's properties.</li>
<li>Continue exploring the AST.</li>
</ol>
<p>Your macros will require a long docstring and many comments both with thorough details.</p>
<p>I present now my macro <code>typeMemoryRepr</code> inspired from the <a href="https://zevv.nl/nim-memory/">nim memory guide</a> on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.</p>
<pre><code class="language-nim">type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
</code></pre>
<p>All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.</p>
<p>I have split this macro into different procedures.
The <code>echoSizeVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return the code:</p>
<pre><code class="language-nim">echo a.field.sizeof
</code></pre>
<p>We create a NimNode of kind <code>StmtList</code> (a statement list), that contains <code>IdentNode</code>s.
The first <code>IdentNode</code> is the command <code>echo</code>.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a <code>nnkDotExpr</code>.</p>
<p>It suffices to output the above code under a <code>dumpTree</code> block, to understand the AST we have to generate.</p>
<pre><code class="language-nim">dumpTree:
  echo a.field.sizeof
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
  newStmtList(nnkCommand.newTree(
            newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
            nnkDotExpr.newTree(
              nnkDotExpr.newTree(
                newIdentNode(variable),
                newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                ),
                newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
            )
            ))</code></pre>
<p>The <code>echoAddressVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return its address:</p>
<pre><code class="language-nim">echo a.field.addr.repr
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
  newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(variable),
                    newIdentNode(nameOfField)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              ))</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
  <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
  <span class="hljs-comment">## * initializes a variable of this type</span>
  <span class="hljs-comment">## * echoes the size and address of the variable</span>
  <span class="hljs-comment">## Then, for each field:</span>
  <span class="hljs-comment">## * echoes the size and address of the variable field</span>

  <span class="hljs-comment"># We begin by running the type definition.</span>
  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`

  <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
  <span class="hljs-comment"># We create the output's AST along parsing.</span>
  <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-comment"># We select only the type section in the StmtList</span>
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-comment">## Generation of AST:</span>
          <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
          quote <span class="hljs-keyword">do</span>:
            <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
            <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
            <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
          )
          <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
            <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr</code></pre>
<pre><code class="nohighlight hljs nim">typeMemoryRepr:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre><pre class="nb-output">32
ptr Thing(a: 0.0, b: &quot;&quot;)
4
ptr 0.0
16
ptr &quot;&quot;</pre>
<p>Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).</p>
<p>There is actually already a function to do so and this will be the object of a future release of this tutorial.</p>
<p><a name = "references-and-bibliography"></a></p>
<h2>References and Bibliography</h2>
<hr />
<p>Press <code>Ctrl</code> + <code>Click</code> to open following links in a new tab.</p>
<p>First, there are four official resources at the Nim's website:</p>
<ol>
<li><a href="https://nim-by-example.github.io/macros/">Nim by Example</a></li>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Manual section about macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">The Standard Documentation of the std/macros library</a>
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.</li>
</ol>
<p>Many developers have written their macro's tutorial:</p>
<ol>
<li><a href="https://learnxinyminutes.com/docs/nim/">Nim in Y minutes</a></li>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>There are plentiful of posts in the forum that are good references:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li><a href="https://forum.nim-lang.org/t/10037">Fast array assignment</a></li>
<li>etc ‚Ä¶ Please use the forum search bar with specific keywords like <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Last but no least, there are three Nim books:</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>.</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>We can also count many projects that are macro- or template-based:</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>My favorite DSL : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a>
<a href="https://github.com/mratsim/">mratsim</a> develops this library, and made <a href="https://forum.nim-lang.org/t/9551#62851">a list of all his DSL</a> in the forum.</p>
</li>
<li>
<p><a href="https://github.com/dom96/jester">Jester</a> library is a HTML DSL, where each block defines a route in your web application.</p>
</li>
<li>
<p><a href="https://pietroppeter.github.io/nimib/">nimib</a> with which this blog post has been written.</p>
</li>
<li>
<p><a href="https://github.com/jmgomez/NimForUE">Nim4UE</a>. You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.</p>
</li>
</ol>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-keyword">import</span> std/[strutils, macros]
<span class="hljs-keyword">import</span> nimib

nbInit

<span class="hljs-comment"># add a ToC</span>
<span class="hljs-keyword">var</span> nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;### Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&lt;h1 style=&quot;text-align: center;&quot;&gt;Nim Metaprogramming - Macro Tutorial&lt;/h1&gt;

This tutorial aims to be a _step-by-step_ introduction to the metaprogramming features of the Nim Language and to provide as much detail as possible to kickstart your craziest projects.
There are already many resources on the Web, but I strive to provide more thorough details on the development process and to gather them all in one place.
&quot;&quot;&quot;</span>

addToc()

nbSection <span class="hljs-string">&quot;Introduction&quot;</span>
nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
### Four levels of abstraction
There are four levels of abstraction in metaprogramming that are each a special kind of procedure:
  1. Ordinary procedures/iterators (No metaprogramming)
  2. Generic procedures/iterators (Type level)
  3. Template (Copy-paste mechanism)
  4. Macro (AST substitution)

It is recommended to start to program one's procedure with the lowest level of metaprogramming possible.
As more metaprogramming features are used, the compilation process takes longer and error debugging gets harder.

Let us start with `template`s and `untyped` parameters.
I do not present generics in this tutorial.

To run each snippet of code in this tutorial, you will need to import the `std/macros` package.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbSection <span class="hljs-string">&quot;Templates&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
We can see *templates* as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : `untyped`.
For those familiar with [preprocessing](https://gcc.gnu.org/onlinedocs/cpp/) in the C family of languages (C, C++, C#), it does the same than the `#define` or `#if`, `#endif` macros and much more.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Nim's language defines boolean operator like `!=` with templates. You can even look at Nim's source code, that's almost the same code. See the [documentation](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">## Example from std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the `duplicate` template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements
    statements

  duplicate:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbCode:
  <span class="hljs-comment">## Example from Nim In Action</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
  <span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
      statements

  repeat <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
#### Do-While keyword
In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a `doWhile` construct similar to languages like `C` or `Javascript`.

For those only knowing Nim, this construct enables to run a loop once before testing the condition.

This C code always print `Hello World` at least once independantly from the start value of the variable `i`.
```cpp
int i = 10;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
```
&quot;&quot;&quot;</span>

nbCode:

  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
  doWhile i &lt; <span class="hljs-number">10</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
      i.inc

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
Notice though that _syntaxically_ the resulting source code is fairly different than the C++ code.

In the C source code, appear in this order:
  1. the `do` keyword
  2. the block of instruction
  3. the `while` keyword
  4. the conditional (boolean expression)

In Nim, we have in this order:
  1. the `doWhile` indent
  2. the conditional
  3. block of instruction

There is no way to modify Nim's syntax as to match C's syntax.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
#### Benchmark example
Another example is benchmarking code in Nim. It suffices to put our bench code inside a special block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">import</span> std/[times, monotimes]
  <span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = getMonoTime()
      code
      <span class="hljs-keyword">let</span> elapsed = getMonoTime() - t0
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] &quot;</span>, elapsed

  benchmark <span class="hljs-string">&quot;test1&quot;</span>:
    sleep(<span class="hljs-number">100</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
The code inside the `benchmark` code block will be enclosed by our template code.

Since the code replacement is done at compile time, this transformation does not add additional runtime to our benchmarked code.
On the contrary, a function or procedure for benchmarking would have add runtime due to the nested function calls.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Macros&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
Template uses `untyped` parameters as lego bricks. It can not break it down into smaller pieces.
We can not check untyped parameters in a template. If our template works when given an object as argument, nothing restrics an user to give a function as argument.

Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
The main difference is that a template can not look inside an untyped parameter. This means that we can not check the input we get as to verify that the user did not give a function when we expect a type.


One can parse untyped parameters with macros. We can even act something conditionally to informations given in these parameters.
We can also inject variables into scopes.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()

  throwAway:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the `macro` `dumpTree`.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]

nbText:<span class="hljs-string">&quot;&quot;&quot;
This output is given with the
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
We can better visualize the AST with the following picture.
&quot;&quot;&quot;</span>

nbImage(url=<span class="hljs-string">&quot;ASTtree.jpg&quot;</span>, caption=<span class="hljs-string">&quot;Nim's Abstract Syntax Tree visualized with a tree&quot;</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Fireship's macro
This example of macro is taken from [this video](https://www.youtube.com/watch?v=WHyOHQ_GkNo)
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>

  timesTwo:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
This macro multiplies each integer values by two before plotting!
Let us breakdown this macro, shall we ?
To understand how a macro work, we first may look at the AST given as input.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
```

`StmtList` stands for *statements list*. It groups together all the instructions in your block.

The `Command` node indicates that you use a function whose name is given by its child `Ident` node. An `Ident` can be any variable, object, procedure name.

Our integer literal whose value is 1 has the node kind `IntLit`.

Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code `1 echo` which does not compile.
```nim
StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
```

`StmtList`, `Command`, `IntLit` and `Ident` are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix `nnk`, e.g. `nnkIdent`.
You can get the full list of node kinds [at the std/macros source code](https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89).

The output of a macro is an AST, and we can try to write it for a few examples:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```
Please note that line breaks are not part of the Nim's AST!

Here, the output AST is almost the same as the input. We only change the integer literal value.

Our root node in the input AST is a statement list.
To fetch the `Command` children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write `statements[0]`.
To loop over all the child nodes, one can use a `for statement in statements` loop.

We need to fetch the nodes under a `Command` instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to `nnkIntLit`. We get their value with the attribute `node.intVal`.
&quot;&quot;&quot;</span>


nbText:<span class="hljs-string">&quot;&quot;&quot;
I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with [some rules](https://en.wikipedia.org/wiki/Data_structure_alignment).

It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.

We can pack a structure with the pragma `{.packed.}`, which removes this extra space. This has the disadvantage to slow down memory accesses.

We would like to detect the presence of holes in an object.

The first step is to look at the AST of the input code we want to parse.

One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;

&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
```nim
typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
```

Type with pragmas aren't supported yet
```nim


when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro does always the same steps:

  1. Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.
  2. Fetch properties of the selected node.
  3. Form AST output in function of these input node's properties.
  4. Continue exploring the AST.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Your macros will require a long docstring and many comments both with thorough details.

I present now my macro `typeMemoryRepr` inspired from the [nim memory guide](https://zevv.nl/nim-memory/) on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.

```nim
type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
```

All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.

I have split this macro into different procedures.
The `echoSizeVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return the code:
```nim
echo a.field.sizeof
```
We create a NimNode of kind `StmtList` (a statement list), that contains `IdentNode`s.
The first `IdentNode` is the command `echo`.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a `nnkDotExpr`.

It suffices to output the above code under a `dumpTree` block, to understand the AST we have to generate.
```nim
dumpTree:
  echo a.field.sizeof
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
    newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(variable),
                  newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              ))

nbText:<span class="hljs-string">&quot;&quot;&quot;
The `echoAddressVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return its address:
```nim
echo a.field.addr.repr
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
    newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(variable),
                      newIdentNode(nameOfField)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                ))


nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
    <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
    <span class="hljs-comment">## * initializes a variable of this type</span>
    <span class="hljs-comment">## * echoes the size and address of the variable</span>
    <span class="hljs-comment">## Then, for each field:</span>
    <span class="hljs-comment">## * echoes the size and address of the variable field</span>

    <span class="hljs-comment"># We begin by running the type definition.</span>
    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`

    <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
    <span class="hljs-comment"># We create the output's AST along parsing.</span>
    <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-comment"># We select only the type section in the StmtList</span>
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-comment">## Generation of AST:</span>
            <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
            )
            <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
              <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr

nbCode:
  typeMemoryRepr:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).

There is actually already a function to do so and this will be the object of a future release of this tutorial.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;References and Bibliography&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Press `Ctrl` + `Click` to open following links in a new tab.

First, there are four official resources at the Nim's website:
  1. [Nim by Example](https://nim-by-example.github.io/macros/)
  2. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
  3. [Manual section about macros](https://nim-lang.org/docs/manual.html#macros)
  4. [The Standard Documentation of the std/macros library](https://nim-lang.org/docs/macros.html)
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.

Many developers have written their macro's tutorial:
  1. [Nim in Y minutes](https://learnxinyminutes.com/docs/nim/)
  2. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  3. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  4. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  5. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

There are plentiful of posts in the forum that are good references:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. [Fast array assignment](https://forum.nim-lang.org/t/10037)
  4. etc ‚Ä¶ Please use the forum search bar with specific keywords like `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Last but no least, there are three Nim books:
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX).
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

We can also count many projects that are macro- or template-based:
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. My favorite DSL : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
  [mratsim](https://github.com/mratsim/) develops this library, and made [a list of all his DSL](https://forum.nim-lang.org/t/9551#62851) in the forum.
  3. [Jester](https://github.com/dom96/jester) library is a HTML DSL, where each block defines a route in your web application.
  4. [nimib](https://pietroppeter.github.io/nimib/) with which this blog post has been written.
  5. [Nim4UE](https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.
&quot;&quot;&quot;</span>
nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>