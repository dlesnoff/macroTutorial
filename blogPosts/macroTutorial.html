<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>macroTutorial.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/androidstudio.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}

.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>macroTutorial.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle; fill: #fff" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></span>
</div>
<hr>
</header><main>
<p>Nim Metaprogramming (Macros) Tutorial
#####################################</p>
<p>This tutorial aims to be a <em>step-by-step</em> introduction to the metaprogramming features of the Nim Language and to provide as much detail as possible to kickstart your project.
There are already many resources on the Web, but I strive to provide more thorough details on the development process all in one place. I still encourage you to code and try things on your behalf.
You will probably learn faster by yourself.</p>
<h2>Existing resources / References / Bibliography</h2>
<p>Press <code>Ctrl</code> + <code>Click</code> to open following links in a new tab.</p>
<p>First, there are three official resources at the Nim's website:
0. <a href="https://nim-by-example.github.io/macros/">Nim by Example</a></p>
<ol>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Manual section about macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">The Standard Documentation of the std/macros library</a>
The 1. and 2. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST for all the nodes.</li>
</ol>
<p>Many developers have written their macro's tutorial:
0. <a href="https://learnxinyminutes.com/docs/nim/">Nim in Y minutes</a></p>
<ol>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>There are plentiful of posts in the forum that are good references:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li>etc ‚Ä¶ Please use the forum search bar with keywords like <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Last but no least, there are three Nim books:</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>.</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>We can also count many projects that are macro- or template-based:</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>My favorite DSL : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a></p>
</li>
<li>
<p><a href="https://github.com/dom96/jester">Jester</a> library is a really nice HTML DSL, where each block defines a route in your web application.</p>
</li>
<li>
<p><a href="https://pietroppeter.github.io/nimib/">nimib</a> with which this blog post has been written, has been developed with a macro DSL too.</p>
</li>
<li>
<p>The most complex macro system that I know of apart from genny for the moment is the Nim4UE(https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.</p>
</li>
</ol>
<h2>Introduction</h2>
<p>There are four kind/levels of procedures:</p>
<ol>
<li>ordinary proc/iterator</li>
<li>generic proc/iterator</li>
<li>template</li>
<li>macro
The higher the number, the more meta we get. It is recommended to program one's procedure with the lowest level of metaprogramming possible.</li>
</ol>
<p>Let us start with <code>template</code>s and <code>untyped</code> parameters. I do not <code>present</code> generics in this tutorial.</p>
<h2>Templates</h2>
<p>We can see <em>templates</em> as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : <code>untyped</code>.
For those familiar with <a href="https://gcc.gnu.org/onlinedocs/cpp/">preprocessing</a> in the C family of languages (C, C++, C#), it does the same than the <code>#define</code> or <code>#if</code>, <code>#endif</code> macros and much more.</p>
<p>Nim's language defines boolean operator like <code>!=</code> with templates. You can even look at Nim's source code, that's almost the same code. See the <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">documentation</a>.</p>
<pre><code class="nim hljs"><span class="hljs-comment">## Example from std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)</code></pre>
<p>We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the <code>duplicate</code> template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements
  statements

duplicate:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre class="nb-output"><samp>5
5</samp></pre>
<pre><code class="nim hljs"><span class="hljs-comment">## Example from Nim In Action</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
<span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
    statements

repeat <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output"><samp>Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!</samp></pre>
<p>In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a <code>doWhile</code> construct.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">proc</span> nextSyracuseTerm(term: <span class="hljs-keyword">var</span> <span class="hljs-built_in">int</span>) =
  <span class="hljs-comment">## This sequence should resolve to the cyclic sequence 1, 4, 2, 1, ...</span>
  <span class="hljs-keyword">if</span> term <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
    term *= <span class="hljs-number">3</span>
    term.inc
  <span class="hljs-keyword">else</span>:
    term = term <span class="hljs-keyword">div</span> <span class="hljs-number">2</span>

<span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> myInt = <span class="hljs-number">5</span>
doWhile myInt &gt;= <span class="hljs-number">6</span>:
    <span class="hljs-keyword">echo</span> myInt
    nextSyracuseTerm(myInt)</code></pre><pre class="nb-output"><samp>5
16
8</samp></pre>
<p>Notice though that the end result is fairly different than C++ code</p>
<pre><code class="language-cpp">int i = 0;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
</code></pre>
<p>The instructions and the conditional appear before the <code>while</code> whereas this doWhile Nim construct will have the conditional after the <code>doWhile</code>:</p>
<pre><code class="language-nim">var i: int = 0 # superfluous type annotation
doWhile i &lt; 10:
  echo &quot;Hello World!&quot;
  i.inc
</code></pre>
<p>Though powerful, templates are still limited. As an example, I didn't achieve to make a discard template (that ta disabling a code.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">template</span> `<span class="hljs-keyword">discard</span>`(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">discard</span> <span class="hljs-literal">nil</span> <span class="hljs-comment"># Cheat here</span>

`<span class="hljs-keyword">discard</span>`:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Test the discard template, if you see this message, it has failed. If not, well ‚Ä¶&quot;</span></code></pre>
<h2>Macros</h2>
<p>Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
Instead of simply taking untyped blocks and reuse them as lego bricks to return a code, we can parse our untyped parameter and do something conditionally to informations given in these parameters.
We can also inject variables into scopes.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()
throwAway:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span></code></pre>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the <code>macro</code> <code>dumpTree</code>.</p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<p>This output is given with the</p>
<pre><code class="language-raw">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory.
We should be able in the future to automatically swap the fields to remove the holes (or at least propose a fixed type).
The first step is to look at the AST of the input code we want to parse.</p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<pre><code class="language-raw">StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
</code></pre>

<p>We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.</p>
<pre><code class="language-nim">  when defined(typeMemoryRepr):
    typeMemoryRepr:
      type
        Thing2 = object
          oneChar: char
          myStr: string
      type
        Thing = object of RootObj
          a: float32
          b: uint64
          c: char
    when false: # erroneous code
      # type with pragmas aren't supported yet
      typeMemoryRepr:
        type
          Thing {.packed.} = object
            oneChar: char
            myStr: string
</code></pre>
<p>It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.</p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<p>StmtList
TypeSection
TypeDef
PragmaExpr
Ident &quot;Thing&quot;
Pragma
Ident &quot;packed&quot;
Empty
ObjectTy
Empty
OfInherit
Ident &quot;RootObj&quot;
RecList
IdentDefs
Ident &quot;a&quot;
Ident &quot;float32&quot;
Empty
IdentDefs
Ident &quot;b&quot;
Ident &quot;string&quot;
Empty</p>
<p>Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.</p>
<p>A macro does three steps in this order:
0. Check that the node is of the expected kind.</p>
<ol>
<li>Get properties of the input AST node (Maybe by going through node child's Ident).</li>
<li>Form AST output in function of these input node's properties.</li>
<li>Go through the node's child.</li>
</ol>
<p>A good macro is necessary complex enough to require a long docstring with thorough details.
We begin by running the type definition.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
  <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
  <span class="hljs-comment">## * initializes a variable of this type</span>
  <span class="hljs-comment">## * echoes the size of the variable</span>
  <span class="hljs-comment">## * echoes the address of the variable</span>
  <span class="hljs-comment">## Then, for each field:</span>
  <span class="hljs-comment">## * echoes the size of the variable field</span>
  <span class="hljs-comment">## * echoes the address of the variable field</span>

  <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`
  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-comment">## Generation of AST:</span>
          <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
          quote <span class="hljs-keyword">do</span>:
            <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate type defined in typedef</span>
            <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
            <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
          )
          <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(nameOfTestVariable),
                  newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal) <span class="hljs-comment"># The name of the field is the first ident</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              )))
            <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>

            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(nameOfTestVariable),
                    newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              )))
  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr</code></pre>
<p>Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).</p>
<p>There is actually already a function to do so:</p>
</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> std/[strutils]
<span class="hljs-keyword">import</span> nimib

nbInit
nb.darkMode

<span class="hljs-keyword">import</span> std/[macros]
nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
Nim Metaprogramming (Macros) Tutorial
#####################################

This tutorial aims to be a _step-by-step_ introduction to the metaprogramming features of the Nim Language and to provide as much detail as possible to kickstart your project.
There are already many resources on the Web, but I strive to provide more thorough details on the development process all in one place. I still encourage you to code and try things on your behalf.
You will probably learn faster by yourself.

## Existing resources / References / Bibliography
Press `Ctrl` + `Click` to open following links in a new tab.

First, there are three official resources at the Nim's website:
  0. [Nim by Example](https://nim-by-example.github.io/macros/)
  1. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
  2. [Manual section about macros](https://nim-lang.org/docs/manual.html#macros)
  3. [The Standard Documentation of the std/macros library](https://nim-lang.org/docs/macros.html)
The 1. and 2. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST for all the nodes.

Many developers have written their macro's tutorial:
  0. [Nim in Y minutes](https://learnxinyminutes.com/docs/nim/)
  1. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  2. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  3. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  4. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

There are plentiful of posts in the forum that are good references:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. etc ‚Ä¶ Please use the forum search bar with keywords like `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Last but no least, there are three Nim books:
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX).
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

We can also count many projects that are macro- or template-based:
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. My favorite DSL : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
  3. [Jester](https://github.com/dom96/jester) library is a really nice HTML DSL, where each block defines a route in your web application.
  4. [nimib](https://pietroppeter.github.io/nimib/) with which this blog post has been written, has been developed with a macro DSL too.
  5. The most complex macro system that I know of apart from genny for the moment is the Nim4UE(https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.

## Introduction
There are four kind/levels of procedures:
  1. ordinary proc/iterator
  2. generic proc/iterator
  3. template
  4. macro
The higher the number, the more meta we get. It is recommended to program one's procedure with the lowest level of metaprogramming possible. 
Let us start with `template`s and `untyped` parameters. I do not `present` generics in this tutorial.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
## Templates
We can see *templates* as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : `untyped`. 
For those familiar with [preprocessing](https://gcc.gnu.org/onlinedocs/cpp/) in the C family of languages (C, C++, C#), it does the same than the `#define` or `#if`, `#endif` macros and much more.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Nim's language defines boolean operator like `!=` with templates. You can even look at Nim's source code, that's almost the same code. See the [documentation](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">## Example from std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the `duplicate` template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements
    statements

  duplicate:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbCode:
  <span class="hljs-comment">## Example from Nim In Action</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
  <span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
      statements

  repeat <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a `doWhile` construct.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> nextSyracuseTerm(term: <span class="hljs-keyword">var</span> <span class="hljs-built_in">int</span>) =
    <span class="hljs-comment">## This sequence should resolve to the cyclic sequence 1, 4, 2, 1, ...</span>
    <span class="hljs-keyword">if</span> term <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
      term *= <span class="hljs-number">3</span>
      term.inc
    <span class="hljs-keyword">else</span>:
      term = term <span class="hljs-keyword">div</span> <span class="hljs-number">2</span>

  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop
  
  <span class="hljs-keyword">var</span> myInt = <span class="hljs-number">5</span>
  doWhile myInt &gt;= <span class="hljs-number">6</span>:
      <span class="hljs-keyword">echo</span> myInt
      nextSyracuseTerm(myInt)

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
Notice though that the end result is fairly different than C++ code
```cpp
int i = 0;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
```
The instructions and the conditional appear before the `while` whereas this doWhile Nim construct will have the conditional after the `doWhile`:
```nim
var i: int = 0 # superfluous type annotation
doWhile i &lt; 10:
  echo &quot;Hello World!&quot;
  i.inc
```
&quot;&quot;&quot;</span>
  
nbText:<span class="hljs-string">&quot;&quot;&quot;
Though powerful, templates are still limited. As an example, I didn't achieve to make a discard template (that ta disabling a code.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> `<span class="hljs-keyword">discard</span>`(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">discard</span> <span class="hljs-literal">nil</span> <span class="hljs-comment"># Cheat here</span>

  `<span class="hljs-keyword">discard</span>`:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Test the discard template, if you see this message, it has failed. If not, well ‚Ä¶&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
## Macros
Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
Instead of simply taking untyped blocks and reuse them as lego bricks to return a code, we can parse our untyped parameter and do something conditionally to informations given in these parameters.
We can also inject variables into scopes.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()
  throwAway:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the `macro` `dumpTree`.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]

nbText:<span class="hljs-string">&quot;&quot;&quot;
This output is given with the
```raw
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory.
We should be able in the future to automatically swap the fields to remove the holes (or at least propose a fixed type).
The first step is to look at the AST of the input code we want to parse.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```raw
StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;

&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
```nim
  when defined(typeMemoryRepr):
    typeMemoryRepr:
      type
        Thing2 = object
          oneChar: char
          myStr: string
      type
        Thing = object of RootObj
          a: float32
          b: uint64
          c: char
    when false: # erroneous code
      # type with pragmas aren't supported yet
      typeMemoryRepr:
        type
          Thing {.packed.} = object
            oneChar: char
            myStr: string
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro does three steps in this order:
  0. Check that the node is of the expected kind.
  1. Get properties of the input AST node (Maybe by going through node child's Ident).
  2. Form AST output in function of these input node's properties.
  3. Go through the node's child.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A good macro is necessary complex enough to require a long docstring with thorough details.
We begin by running the type definition.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
    <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
    <span class="hljs-comment">## * initializes a variable of this type</span>
    <span class="hljs-comment">## * echoes the size of the variable</span>
    <span class="hljs-comment">## * echoes the address of the variable</span>
    <span class="hljs-comment">## Then, for each field:</span>
    <span class="hljs-comment">## * echoes the size of the variable field</span>
    <span class="hljs-comment">## * echoes the address of the variable field</span>

    <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`
    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-comment">## Generation of AST:</span>
            <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate type defined in typedef</span>
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
            )
            <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(nameOfTestVariable),
                    newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal) <span class="hljs-comment"># The name of the field is the first ident</span>
                    ),
                    newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
                )
                )))
              <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>

              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(nameOfTestVariable),
                      newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                )))
    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr



nbText:<span class="hljs-string">&quot;&quot;&quot;
Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).

There is actually already a function to do so:
&quot;&quot;&quot;</span>

nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>