<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>macroTutorial_fr.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.12" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
figure {
  margin: 2rem 0;
}
figcaption {
  text-align: center;
}
  
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>macroTutorial_fr.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1 style="text-align: center;">Les macros avec Nim - tutoriel de m√©taprogrammation</h1>
<p>Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets les plus fous.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.</p>
<p>‚ö†Ô∏è Une partie du tutoriel n'a pas encore √©t√© traduit de l'anglais vers le fran√ßais.</p>
<h3>Plan:</h3>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#proc√©dures-g√©n√©riques">Proc√©dures G√©n√©riques</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#references-and-bibliography">References and Bibliography</a></li>
</ol>
<p><a name = "introduction"></a></p>
<h2>Introduction</h2>
<hr />
<blockquote>
<p>Qu'est-ce que la m√©taprogrammation ?</p>
</blockquote>
<p>La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.</p>
<blockquote>
<p>Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?</p>
</blockquote>
<p>Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec <code>Owlkettle</code>
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones <code>Arraymancer</code>. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.</p>
<blockquote>
<p>Quel rapport avec les macros ?</p>
</blockquote>
<p>Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.</p>
<h3>Quatre niveaux d'abstraction</h3>
<p>Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:</p>
<ol start="0">
<li>Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)</li>
<li>Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)</li>
<li>Les ¬´ mod√®les ¬ª <code>template</code> en anglais (Un m√©chanisme de copier-coller avanc√©)</li>
<li>Les <code>Macro</code>s (Substitution d'arbre syntaxique <code>AST</code>)</li>
</ol>
<p>Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.</p>
<p>Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p><a name = "proc√©dures-g√©n√©riques"></a></p>
<h2>Proc√©dures G√©n√©riques</h2>
<hr />
<p>Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.</p>
<p>Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.</p>
<p>Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># What to not do!</span>
<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)</code></pre><pre class="nb-output">5
8.199999999999999</pre>
<p>En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme <code>int32</code> ou <code>float16</code>?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.</p>
<p>Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.</p>
<p>Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© <code>or</code> comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
  <span class="hljs-keyword">return</span> x + y

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span></code></pre>
<p>Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourraient √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    x = x.parseFloat()
    y = y.parseFloat()
  <span class="hljs-keyword">var</span> c = x + y
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    <span class="hljs-keyword">return</span> $c
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> c

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span></code></pre>
<p><a name = "templates"></a></p>
<h2>Templates</h2>
<hr />
<p>‚ö†Ô∏è Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet <code>std/macros</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p>Nous pouvons voir les <em>templates</em> comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.</p>
<p>Les proc√©dures <code>templates</code> re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est <code>untyped</code>.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est <code>untyped</code> pour presque tous les cas d'usage.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Exemple provenant de std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>) <span class="hljs-comment"># Appelle le template `!=` d√©finit ci-dessus.</span></code></pre>
<p>Le langage d√©finit l'op√©rateur bool√©en <code>!=</code> exactement comme ci-dessus. Le code source de Nim avec cet exemple est consultable librement √† <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">cette addresse</a>.</p>
<p>On peut facilement dupliquer du code √† l'aide d'un bloc personnalis√©. Attention, on ex√©cute deux fois de suite l'instruction, et donc on ne peux donc pas placer d'affectation en-dessous de ce
template.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements <span class="hljs-comment"># statements est remplac√© par `echo 5` lors de l'appel</span>
  statements

duplicate: <span class="hljs-comment"># A template can receive its last argument as a code</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre class="nb-output">5
5</pre>
<p>Ci-dessous, on g√©n√©ralise l'id√©e pour r√©p√©ter le code autant de fois que d√©sir√©.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Exemple provenant de Nim In Action de Dominik Picheta</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep

<span class="hljs-comment"># On garde les instructions en second argument</span>
<span class="hljs-keyword">template</span> repetition(compteur: <span class="hljs-built_in">int</span>, instructions: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; compteur:
    instructions

repetition <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Salut. Je vais dormir 100 millisecondes!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)

<span class="hljs-comment">## Le code est remplac√© par:</span>
<span class="hljs-comment">## for i in 0 ..&lt; 5:</span>
<span class="hljs-comment">##   echo(&quot;Salut. Je vais dormir 100 millisecondes!&quot;)</span>
<span class="hljs-comment">##   sleep(100)</span></code></pre><pre class="nb-output">Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!</pre>
<h4>Le mot-cl√© Do-While</h4>
<p>Nim poss√®de peu de mots-cl√©s et de m√©chanismes de flots de contr√¥le, afin de garder le langage simple √† appr√©hender. Cependant, on peut toujours d√©finir un mot-cl√© <code>doWhile</code> que l'on retrouve dans d'autres langages comme <code>C</code> ou <code>Javascript</code>.
Ce mot-cl√© est quasiment identique √† la boucle <code>While</code>, √† l'exception pr√®s qu'elle teste la condition apr√®s le bloc d'instruction. Cela permet de toujours ex√©cuter au-moins une fois le bloc d'instruction.</p>
<p>Par exemple, ce code C affiche <code>Hello World</code> au moins une fois, ind√©pendamment de la valeur de d√©part de la variable <code>i</code>.</p>
<pre><code class="language-cpp">int i = 10; // On doit d√©clarer une variable pour la boucle
do{
  printf(&quot;Hello World\n&quot;);
  i += 1;
}while(i &lt; 10); // do{}while; est une unique instruction
// sur plusieurs lignes, d'o√π le point-virgule √† la fin
</code></pre>
<p>Nous allons recr√©er ce code C avec Nim. Techniquement, nous allons nous servir d'une boucle while pour construire la boucle do-while.
Nous ne pourrons cependant pas obtenir la m√™me syntaxe qu'en C, o√π la condition est affich√©e √† la fin du bloc d'instruction.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
doWhile i &lt; <span class="hljs-number">10</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
    i.inc

<span class="hljs-comment">## Le template modifie le code pour que soit ex√©cut√©:</span>
<span class="hljs-comment">## echo &quot;Hello World&quot;</span>
<span class="hljs-comment">## i.inc</span>
<span class="hljs-comment">## while i &lt; 10:</span>
<span class="hljs-comment">##   echo &quot;Hello World&quot;</span>
<span class="hljs-comment">##   i.inc</span>
<span class="hljs-comment">##</span>
<span class="hljs-comment">## Ceci est strictement √©quivalent au code C pr√©sent√© ci-dessous.</span></code></pre><pre class="nb-output">Hello World</pre>
<p>Vous noterez cependant que <em>syntaxiquement</em> le code source qu'il est alors permis d'√©crire est diff√©rent du code C++.</p>
<p>En effet, dans le code source C, apparaissent dans l'ordre:</p>
<ol>
<li>le mot-cl√© <code>do</code></li>
<li>le bloc d'instruction</li>
<li>le mot-cl√© <code>while</code></li>
<li>la condition (expression bool√©enne)</li>
</ol>
<p>Avec Nim, on a dans cet ordre:
In Nim, we have in this order:</p>
<ol>
<li>le mot-cl√© <code>doWhile</code></li>
<li>la condition</li>
<li>le bloc d'instruction</li>
</ol>
<p>Nous ne pouvons pas modifier la syntaxe de Nim pour correspondre √† la syntaxe du C.</p>
<h4>√âvaluer le temps d'ex√©cution</h4>
<p>Pour √©valuer le temps d'ex√©cution d'un bout de code, on r√©cup√®re l'heure avant et apr√®s l'ex√©cution, et on affiche la diff√©rence.
Avec Nim, on utilise la fonction <code>getMonoTime</code>.
Plut√¥t que d'√©crire quatre lignes suppl√©mentaires pour chaque bout de code dont on veut mesurer le temps d'ex√©cution, il nous suffit d'√©crire
le template suivant:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## √âvaluation du temps d'ex√©cution</span>
<span class="hljs-keyword">import</span> std/[times, monotimes] <span class="hljs-comment"># times permet un affichage plus lisible d'un `MonoTime`</span>

<span class="hljs-keyword">template</span> benchmark(nomBenchmark: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = getMonoTime() <span class="hljs-comment"># https://nim-lang.org/docs/monotimes.html#getMonoTime</span>
    code
    <span class="hljs-keyword">let</span> √©coul√© = getMonoTime() - t0
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, nomBenchmark, <span class="hljs-string">&quot;] &quot;</span>, √©coul√©

benchmark <span class="hljs-string">&quot;test1&quot;</span>: <span class="hljs-comment"># Devrait retourner une valeur proche de 100 ms</span>
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">CPU Time [test1] 100 milliseconds, 183 microseconds, and 909 nanoseconds</pre>
<p>Le code qui est indent√© en-dessous du bloc <code>benchmark</code> sera d√©limit√© par le code du benchmark.</p>
<p>Puisque la substitution du code est r√©alis√©e au moment de la compilation, cette transformation ne modifie pas les temps obtenus.</p>
<p>Exercice:
Modifier le code pr√©c√©dent pour effectuer une moyenne des temps obtenus apr√®s autant de r√©p√©titions que demander par l'utilisateur.</p>
<p><a name = "macros"></a></p>
<h2>Macros</h2>
<hr />
<p>Les Templates utilisent les param√®tres <code>untyped</code> comme des briques de LEGO¬©, c'est-√†-dire comme du code indivisible qui ne peut-√™tre inspect√© pour ses propri√©t√©s.
Si par exemple, nous ne voulions pas que l'utilisateur de notre template passe en argument un code contenant des d√©clarations, nous ne pourrions le v√©rifier avec un template.
L'utilisateur obtiendrait alors une erreur due √† son mauvais usage de la fonction sans que nous puissions faire quelque chose pour l'en emp√™cher.</p>
<p>Les <code>macro</code>s sont en quelque sorte des <code>template</code> am√©lior√©es qui peuvent analyser le code qu'elles re√ßoivent en argument.</p>
<p>¬´ Tandis que les templates remplacent du code, les macros r√©alisent une introspection. ¬ª</p>
<p>Ici, une introspection de code signifie en analyser le contenu: pr√©sence de d√©finitions, analyser les types utilis√©s, etc‚Ä¶</p>
<p>Au-del√†, de l'introspection, les <code>macro</code>s vont pouvoir retourner une version modifi√©e du code pass√© en argument en injectant des variables dans le code original.</p>
<p>En premier exemple de <code>macro</code>, j'ai choisi la macro la plus simple possible puisqu'elle ne retourne rien, ou plus pr√©cis√©ment, une liste vide d'instructions.
Le code qui lui est pass√© en argument provoquerait une boucle infinie si ex√©cut√©. Heureusement, le code g√©n√©r√© par la macro √©tant vide, rien n'est ex√©cut√©.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> jetteAuxOubliettes(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()

jetteAuxOubliettes:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Si tu ne fais rien, je te spammerai ind√©finiment !&quot;</span></code></pre>
<h3>Arbre syntaxique abstrait</h3>
<p>Un arbre syntaxique (abstrait) (en anglais AST pour &quot;abstract syntaxic tree&quot;) est une repr√©sentation du code interne au compilateur, qui est dite interm√©diaire, car elle repr√©sente le code entre le code source (compr√©hensible par un humain) et le code g√©n√©r√© (difficilement compr√©hensible par un humain mais pour un compilateur: code C, C++, Objective-C, ou Javascript selon le <code>backend</code>).</p>
<p>Chaque code source Nim a son √©quivalent en AST. En revanche plusieurs codes sources peuvent correspondre √† un AST.</p>
<p>Les commentaires et espaces du code source sont supprim√©s.</p>
<p>L'arbre syntaxique repr√©sente le code source sous la forme d'une arborescence ordonn√©e. L'AST est form√©e de n≈ìuds qui poss√®dent chacun un ou plusieurs n≈ìuds enfants. Ces n≈ìuds ne peuvent √™tre intervertis sans changer le sens du code.</p>
<p>Pour obtenir une repr√©sentation du code syntaxique d'un code, on peut √©crire ce code sous une <code>macro</code> sp√©ciale appel√©e <code>dumpTree</code>.</p>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the <code>macro</code> <code>dumpTree</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># N'oubliez pas d'importer std/macros!</span>
<span class="hljs-comment"># Vous pouvez utiliser --hints:off pour mieux discerner l'Arbre syntaxique</span>
dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Salut!&quot;</span></code></pre>
<p>Vous trouverez dans la sortie du compilateur l'AST suivant:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    StrLit &quot;Salut!&quot;
</code></pre>
<p>Ce code contient quatre n≈ìuds. <code>StmtList</code> est √† la racine de l'arbre, puis chaque indentation d√©signe que l'on passe √† un n≈ìud enfant, √† un niveau inf√©rieur dans la hi√©rarchie.</p>
<p><code>StmtList</code> est la contraction de <em>statements list</em> qui signifie bloc d'instructions. Il rassemble ensemble toutes les instructions dans le bloc.</p>
<p>Le n≈ìud suivant <code>Command</code> indique que l'on utilise une proc√©dure dont le nom est donn√© par son n≈ìud enfant <code>Ident</code>. Un <code>Ident</code> peut-√™tre le nom d'une variable, d'un objet ou d'une proc√©dure.
Le n≈ìud <code>Command</code> pr√©cise la fa√ßon dont la proc√©dure est appel√©e. Je ne d√©taille pas ici, mais cela a un rapport avec l'UFCS: Uniform Function Call Syntax qui est une propri√©t√© du langage qui indique qu'une fonction ou proc√©dure peut √™tre appel√©e indiff√©remment avec trois syntaxes distinctes.</p>
<p>Nous avons ensuite deux n≈ìuds avec du texte accol√© √† la suite. Les n≈ìuds correspondants √† des noms de variables ou de proc√©dures sont des n≈ìuds de type <code>Ident</code>.
Les chaines de caract√®res sont des n≈ìuds de type <code>StrLit</code>.</p>
<p>Afin de vous donner une id√©e de ce qui se passe en g√©n√©ral, voici un exemple d'un code nettement plus complexe.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># Don't forget to import std/macros!</span>
<span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<p>Ce code donne en sortie l'arbre syntaxique suivant:</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>L'AST retourn√© par <code>dumpTree</code> d√©marrera sauf quelques exceptions toujours par <code>StmtList</code>.
Les d√©finitions de type se retrouvent toujours dans une <code>TypeSection</code> qui poss√®dent autant d'enfants de type <code>TypeDef</code> que de d√©finitions.
Les types objets sont d√©finis par des <code>ObjectTy</code>.</p>
<p>Afin de mieux visualiser l'hi√©rarchie, vous trouverez ci-dessous un sch√©ma de l'AST:</p>
<figure>
<img src="./pictures/ASTtree.jpg" alt="Arbre syntaxique de la d√©finition du type myObject">
<figcaption>Arbre syntaxique de la d√©finition du type myObject</figcaption>
</figure>
<p>Il n'est pas n√©cessaire que vous compreniez l'ensemble de la g√©n√©ration de l'AST. Sachez simplement que vous pouvez l'obtenir avec la commande <code>DumpTree</code>.
Si jamais vous avez besoin d'√©crire vous m√™me un AST pour une macro, sachez que des exemples pour toutes les structures et mots-clefs sont dans la documentation des macros:
<a href="https://nim-lang.org/docs/macros.html">std/macros</a></p>
<h3>Premier exemple de Macro: multiplication par deux</h3>
<p>La premi√®re macro que je vous pr√©sente provient de cette <a href="https://www.youtube.com/watch?v=WHyOHQ_GkNo">vid√©o Youtube</a> r√©alis√©e par <a href="https://www.youtube.com/c/Fireship">Jeff Delaunay sur sa cha√Æne Fireship</a>.</p>
<p>Lorsque un utilisateur d√©sire afficher des valeurs enti√®res sous cette macro, les valeurs seront multipli√©es par deux.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>
timesTwo:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span></code></pre>
<p>Avant d'expliciter le fonctionnement de la macro, on va comparer l'AST du code donn√© en entr√©e,
avec celui que l'on pense obtenir avec le code:</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>
dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">4</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">6</span></code></pre>
<p>Le compilateur retourne:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 3
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Cette sortie ressemble √† s'y m√©prendre au premier exemple d'AST vu pr√©c√©demment.
Au lieu du StrLit &quot;Salut!&quot;, on a d√©sormais IntLit suivi du nombre pr√©sent dans le code source ou dans la sortie.</p>
<p>By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
</code></pre>
<p><code>StmtList</code> stands for <em>statements list</em>. It groups together all the instructions in your block.</p>
<p>The <code>Command</code> node indicates that you use a function whose name is given by its child <code>Ident</code> node. An <code>Ident</code> can be any variable, object, procedure name.</p>
<p>Our integer literal whose value is 1 has the node kind <code>IntLit</code>.</p>
<p>Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code <code>1 echo</code> which does not compile.</p>
<pre><code class="language-nim">StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
</code></pre>
<p><code>StmtList</code>, <code>Command</code>, <code>IntLit</code> and <code>Ident</code> are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix <code>nnk</code>, e.g. <code>nnkIdent</code>.
You can get the full list of node kinds <a href="https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89">at the std/macros source code</a>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwoAndEcho(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> repr <span class="hljs-literal">result</span>

timesTwoAndEcho:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span></code></pre>
<p>The output of a macro is an AST, and we can try to write it for a few examples:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Please note that line breaks are not part of the Nim's AST!</p>
<p>Here, the output AST is almost the same as the input. We only change the integer literal value.</p>
<p>Our root node in the input AST is a statement list.
To fetch the <code>Command</code> children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write <code>statements[0]</code>.
To loop over all the child nodes, one can use a <code>for statement in statements</code> loop.</p>
<p>We need to fetch the nodes under a <code>Command</code> instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to <code>nnkIntLit</code>. We get their value with the attribute <code>node.intVal</code>.</p>
<p>I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">some rules</a>.</p>
<p>It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.</p>
<p>We can pack a structure with the pragma <code>{.packed.}</code>, which removes this extra space. This has the disadvantage to slow down memory accesses.</p>
<p>We would like to detect the presence of holes in an object.</p>
<p>The first step is to look at the AST of the input code we want to parse.</p>
<p>One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
</code></pre>

<p>We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.</p>
<pre><code class="language-nim">typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
</code></pre>
<p>Type with pragmas aren't supported yet</p>
<pre><code class="language-nim">

when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
</code></pre>
<p>It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
</code></pre>
<p>Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.</p>
<p>A macro does always the same steps:</p>
<ol>
<li>Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.</li>
<li>Fetch properties of the selected node.</li>
<li>Form AST output in function of these input node's properties.</li>
<li>Continue exploring the AST.</li>
</ol>
<p>Your macros will require a long docstring and many comments both with thorough details.</p>
<p>I present now my macro <code>typeMemoryRepr</code> inspired from the <a href="https://zevv.nl/nim-memory/">nim memory guide</a> on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.</p>
<pre><code class="language-nim">type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
</code></pre>
<p>All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.</p>
<p>I have split this macro into different procedures.
The <code>echoSizeVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return the code:</p>
<pre><code class="language-nim">echo a.field.sizeof
</code></pre>
<p>We create a NimNode of kind <code>StmtList</code> (a statement list), that contains <code>IdentNode</code>s.
The first <code>IdentNode</code> is the command <code>echo</code>.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a <code>nnkDotExpr</code>.</p>
<p>It suffices to output the above code under a <code>dumpTree</code> block, to understand the AST we have to generate.</p>
<pre><code class="language-nim">dumpTree:
  echo a.field.sizeof
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
  newStmtList(nnkCommand.newTree(
            newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
            nnkDotExpr.newTree(
              nnkDotExpr.newTree(
                newIdentNode(variable),
                newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                ),
                newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
            )
            ))</code></pre>
<p>The <code>echoAddressVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return its address:</p>
<pre><code class="language-nim">echo a.field.addr.repr
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
  newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(variable),
                    newIdentNode(nameOfField)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              ))</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
  <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
  <span class="hljs-comment">## * initializes a variable of this type</span>
  <span class="hljs-comment">## * echoes the size and address of the variable</span>
  <span class="hljs-comment">## Then, for each field:</span>
  <span class="hljs-comment">## * echoes the size and address of the variable field</span>

  <span class="hljs-comment"># We begin by running the type definition.</span>
  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`

  <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
  <span class="hljs-comment"># We create the output's AST along parsing.</span>
  <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-comment"># We select only the type section in the StmtList</span>
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-comment">## Generation of AST:</span>
          <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
          quote <span class="hljs-keyword">do</span>:
            <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
            <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
            <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
          )
          <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
            <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr</code></pre>
<pre><code class="nohighlight hljs nim">typeMemoryRepr:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre><pre class="nb-output">32
ptr Thing(a: 0.0, b: &quot;&quot;)
4
ptr 0.0
16
ptr &quot;&quot;</pre>
<p>Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).</p>
<p>There is actually already a function to do so and this will be the object of a future release of this tutorial.</p>
<p>The following macro enables to create enums with power of two values.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/[enumerate, math]</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># jmgomez on Discord</span>
<span class="hljs-keyword">macro</span> power2Enum(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">let</span> srcFields = body[^<span class="hljs-number">1</span>][<span class="hljs-number">1.</span>.^<span class="hljs-number">1</span>]
  <span class="hljs-keyword">var</span> dstFields =  nnkEnumTy.newTree(newEmptyNode())
  <span class="hljs-keyword">for</span> idx, field <span class="hljs-keyword">in</span> enumerate(srcFields):
    dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(<span class="hljs-number">2.0</span>, idx.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">int</span>))

  body[^<span class="hljs-number">1</span>] = dstFields
  <span class="hljs-keyword">echo</span> repr body
  body


<span class="hljs-keyword">type</span> <span class="hljs-type">Test</span> {.power2Enum.}  = <span class="hljs-keyword">enum</span>
  a, b, c, d</code></pre>
<p>A macro is not always the best alternative. A simple set and a cast gives the same result.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># Rika</span>
<span class="hljs-keyword">type</span>
  <span class="hljs-type">Setting</span> = <span class="hljs-keyword">enum</span>
    a, b, c
  <span class="hljs-type">Settings</span> = <span class="hljs-built_in">set</span>[<span class="hljs-type">Setting</span>]
<span class="hljs-keyword">let</span> settings: <span class="hljs-type">Settings</span> = {a, c}
<span class="hljs-keyword">echo</span> <span class="hljs-keyword">cast</span>[<span class="hljs-built_in">uint8</span>](settings)</code></pre><pre class="nb-output">5</pre>
<p><a name = "references-and-bibliography"></a></p>
<h2>References and Bibliography</h2>
<hr />
<p>Press <code>Ctrl</code> + <code>Click</code> to open following links in a new tab.</p>
<p>First, there are four official resources at the Nim's website:</p>
<ol>
<li><a href="https://nim-by-example.github.io/macros/">Nim by Example</a></li>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Manual section about macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">The Standard Documentation of the std/macros library</a>
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.</li>
</ol>
<p>Many developers have written their macro's tutorial:</p>
<ol>
<li><a href="https://learnxinyminutes.com/docs/nim/">Nim in Y minutes</a></li>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>There are plentiful of posts in the forum that are good references:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li><a href="https://forum.nim-lang.org/t/10037">Fast array assignment</a></li>
<li><a href="https://forum.nim-lang.org/t/10513">Variable injection</a></li>
<li><a href="https://forum.nim-lang.org/t/9127">Proc inspection</a></li>
<li>etc ‚Ä¶ Please use the forum search bar with specific keywords like <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Last but no least, there are three Nim books:</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>.</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>We can also count many projects that are macro- or template-based:</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>My favorite DSL : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a>
<a href="https://github.com/mratsim/">mratsim</a> develops this library, and made <a href="https://forum.nim-lang.org/t/9551#62851">a list of all his DSL</a> in the forum.</p>
</li>
<li>
<p><a href="https://github.com/dom96/jester">Jester</a> library is a HTML DSL, where each block defines a route in your web application.</p>
</li>
<li>
<p><a href="https://pietroppeter.github.io/nimib/">nimib</a> with which this blog post has been written.</p>
</li>
<li>
<p><a href="https://github.com/jmgomez/NimForUE">Nim4UE</a>. You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.</p>
</li>
</ol>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-keyword">import</span> std/[strutils, macros]
<span class="hljs-keyword">import</span> std/[enumerate, math]
<span class="hljs-keyword">import</span> nimib, nimoji

nbInit

<span class="hljs-comment"># add a ToC</span>
<span class="hljs-keyword">var</span> nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;### Plan:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&lt;h1 style=&quot;text-align: center;&quot;&gt;Les macros avec Nim - tutoriel de m√©taprogrammation&lt;/h1&gt;

Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets les plus fous.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.

&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
:warning: Une partie du tutoriel n'a pas encore √©t√© traduit de l'anglais vers le fran√ßais.
&quot;&quot;&quot;</span>.emojize()

addToc()

nbSection <span class="hljs-string">&quot;Introduction&quot;</span>
nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&gt; Qu'est-ce que la m√©taprogrammation ?

La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.

&gt; Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?

Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec `Owlkettle`
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones `Arraymancer`. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.

&gt; Quel rapport avec les macros ?

Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
### Quatre niveaux d'abstraction
Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:

  0. Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)
  1. Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)
  2. Les ¬´ mod√®les ¬ª `template` en anglais (Un m√©chanisme de copier-coller avanc√©)
  3. Les `Macro`s (Substitution d'arbre syntaxique `AST`)

Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.

Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbSection <span class="hljs-string">&quot;Proc√©dures G√©n√©riques&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.

Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.

Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># What to not do!</span>
  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme `int32` ou `float16`?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.

Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.

Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© `or` comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
    <span class="hljs-keyword">return</span> x + y

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourraient √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      x = x.parseFloat()
      y = y.parseFloat()
    <span class="hljs-keyword">var</span> c = x + y
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      <span class="hljs-keyword">return</span> $c
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span> c

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
  add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span>

nbSection <span class="hljs-string">&quot;Templates&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
:warning: Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet `std/macros`.
&quot;&quot;&quot;</span>.emojize

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbText: <span class="hljs-string">&quot;&quot;&quot;
Nous pouvons voir les *templates* comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.

Les proc√©dures `templates` re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est `untyped`.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est `untyped` pour presque tous les cas d'usage.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## Exemple provenant de std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>) <span class="hljs-comment"># Appelle le template `!=` d√©finit ci-dessus.</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Le langage d√©finit l'op√©rateur bool√©en `!=` exactement comme ci-dessus. Le code source de Nim avec cet exemple est consultable librement √† [cette addresse](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
On peut facilement dupliquer du code √† l'aide d'un bloc personnalis√©. Attention, on ex√©cute deux fois de suite l'instruction, et donc on ne peux donc pas placer d'affectation en-dessous de ce
template.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements <span class="hljs-comment"># statements est remplac√© par `echo 5` lors de l'appel</span>
    statements

  duplicate: <span class="hljs-comment"># A template can receive its last argument as a code</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Ci-dessous, on g√©n√©ralise l'id√©e pour r√©p√©ter le code autant de fois que d√©sir√©.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## Exemple provenant de Nim In Action de Dominik Picheta</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep

  <span class="hljs-comment"># On garde les instructions en second argument</span>
  <span class="hljs-keyword">template</span> repetition(compteur: <span class="hljs-built_in">int</span>, instructions: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; compteur:
      instructions

  repetition <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Salut. Je vais dormir 100 millisecondes!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

  <span class="hljs-comment">## Le code est remplac√© par:</span>
  <span class="hljs-comment">## for i in 0 ..&lt; 5:</span>
  <span class="hljs-comment">##   echo(&quot;Salut. Je vais dormir 100 millisecondes!&quot;)</span>
  <span class="hljs-comment">##   sleep(100)</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
#### Le mot-cl√© Do-While
Nim poss√®de peu de mots-cl√©s et de m√©chanismes de flots de contr√¥le, afin de garder le langage simple √† appr√©hender. Cependant, on peut toujours d√©finir un mot-cl√© `doWhile` que l'on retrouve dans d'autres langages comme `C` ou `Javascript`.
Ce mot-cl√© est quasiment identique √† la boucle `While`, √† l'exception pr√®s qu'elle teste la condition apr√®s le bloc d'instruction. Cela permet de toujours ex√©cuter au-moins une fois le bloc d'instruction.

Par exemple, ce code C affiche `Hello World` au moins une fois, ind√©pendamment de la valeur de d√©part de la variable `i`.
```cpp
int i = 10; // On doit d√©clarer une variable pour la boucle
do{
  printf(&quot;Hello World\n&quot;);
  i += 1;
}while(i &lt; 10); // do{}while; est une unique instruction
// sur plusieurs lignes, d'o√π le point-virgule √† la fin
```
Nous allons recr√©er ce code C avec Nim. Techniquement, nous allons nous servir d'une boucle while pour construire la boucle do-while.
Nous ne pourrons cependant pas obtenir la m√™me syntaxe qu'en C, o√π la condition est affich√©e √† la fin du bloc d'instruction.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
  doWhile i &lt; <span class="hljs-number">10</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
      i.inc

  <span class="hljs-comment">## Le template modifie le code pour que soit ex√©cut√©:</span>
  <span class="hljs-comment">## echo &quot;Hello World&quot;</span>
  <span class="hljs-comment">## i.inc</span>
  <span class="hljs-comment">## while i &lt; 10:</span>
  <span class="hljs-comment">##   echo &quot;Hello World&quot;</span>
  <span class="hljs-comment">##   i.inc</span>
  <span class="hljs-comment">##</span>
  <span class="hljs-comment">## Ceci est strictement √©quivalent au code C pr√©sent√© ci-dessous.</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
Vous noterez cependant que _syntaxiquement_ le code source qu'il est alors permis d'√©crire est diff√©rent du code C++.

En effet, dans le code source C, apparaissent dans l'ordre:
  1. le mot-cl√© `do`
  2. le bloc d'instruction
  3. le mot-cl√© `while`
  4. la condition (expression bool√©enne)

Avec Nim, on a dans cet ordre:
In Nim, we have in this order:
  1. le mot-cl√© `doWhile`
  2. la condition
  3. le bloc d'instruction

Nous ne pouvons pas modifier la syntaxe de Nim pour correspondre √† la syntaxe du C.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
#### √âvaluer le temps d'ex√©cution
Pour √©valuer le temps d'ex√©cution d'un bout de code, on r√©cup√®re l'heure avant et apr√®s l'ex√©cution, et on affiche la diff√©rence.
Avec Nim, on utilise la fonction `getMonoTime`.
Plut√¥t que d'√©crire quatre lignes suppl√©mentaires pour chaque bout de code dont on veut mesurer le temps d'ex√©cution, il nous suffit d'√©crire
le template suivant:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## √âvaluation du temps d'ex√©cution</span>
  <span class="hljs-keyword">import</span> std/[times, monotimes] <span class="hljs-comment"># times permet un affichage plus lisible d'un `MonoTime`</span>

  <span class="hljs-keyword">template</span> benchmark(nomBenchmark: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = getMonoTime() <span class="hljs-comment"># https://nim-lang.org/docs/monotimes.html#getMonoTime</span>
      code
      <span class="hljs-keyword">let</span> √©coul√© = getMonoTime() - t0
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, nomBenchmark, <span class="hljs-string">&quot;] &quot;</span>, √©coul√©

  benchmark <span class="hljs-string">&quot;test1&quot;</span>: <span class="hljs-comment"># Devrait retourner une valeur proche de 100 ms</span>
    sleep(<span class="hljs-number">100</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
Le code qui est indent√© en-dessous du bloc `benchmark` sera d√©limit√© par le code du benchmark.

Puisque la substitution du code est r√©alis√©e au moment de la compilation, cette transformation ne modifie pas les temps obtenus.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Exercice:
  Modifier le code pr√©c√©dent pour effectuer une moyenne des temps obtenus apr√®s autant de r√©p√©titions que demander par l'utilisateur.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Macros&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
Les Templates utilisent les param√®tres `untyped` comme des briques de LEGO¬©, c'est-√†-dire comme du code indivisible qui ne peut-√™tre inspect√© pour ses propri√©t√©s.
Si par exemple, nous ne voulions pas que l'utilisateur de notre template passe en argument un code contenant des d√©clarations, nous ne pourrions le v√©rifier avec un template.
L'utilisateur obtiendrait alors une erreur due √† son mauvais usage de la fonction sans que nous puissions faire quelque chose pour l'en emp√™cher.

Les `macro`s sont en quelque sorte des `template` am√©lior√©es qui peuvent analyser le code qu'elles re√ßoivent en argument.

¬´ Tandis que les templates remplacent du code, les macros r√©alisent une introspection. ¬ª

Ici, une introspection de code signifie en analyser le contenu: pr√©sence de d√©finitions, analyser les types utilis√©s, etc‚Ä¶

Au-del√†, de l'introspection, les `macro`s vont pouvoir retourner une version modifi√©e du code pass√© en argument en injectant des variables dans le code original.

En premier exemple de `macro`, j'ai choisi la macro la plus simple possible puisqu'elle ne retourne rien, ou plus pr√©cis√©ment, une liste vide d'instructions.
Le code qui lui est pass√© en argument provoquerait une boucle infinie si ex√©cut√©. Heureusement, le code g√©n√©r√© par la macro √©tant vide, rien n'est ex√©cut√©.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> jetteAuxOubliettes(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()

  jetteAuxOubliettes:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Si tu ne fais rien, je te spammerai ind√©finiment !&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Arbre syntaxique abstrait

Un arbre syntaxique (abstrait) (en anglais AST pour &quot;abstract syntaxic tree&quot;) est une repr√©sentation du code interne au compilateur, qui est dite interm√©diaire, car elle repr√©sente le code entre le code source (compr√©hensible par un humain) et le code g√©n√©r√© (difficilement compr√©hensible par un humain mais pour un compilateur: code C, C++, Objective-C, ou Javascript selon le `backend`).

Chaque code source Nim a son √©quivalent en AST. En revanche plusieurs codes sources peuvent correspondre √† un AST.

Les commentaires et espaces du code source sont supprim√©s.

L'arbre syntaxique repr√©sente le code source sous la forme d'une arborescence ordonn√©e. L'AST est form√©e de n≈ìuds qui poss√®dent chacun un ou plusieurs n≈ìuds enfants. Ces n≈ìuds ne peuvent √™tre intervertis sans changer le sens du code.

Pour obtenir une repr√©sentation du code syntaxique d'un code, on peut √©crire ce code sous une `macro` sp√©ciale appel√©e `dumpTree`.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the `macro` `dumpTree`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment"># N'oubliez pas d'importer std/macros!</span>
  <span class="hljs-comment"># Vous pouvez utiliser --hints:off pour mieux discerner l'Arbre syntaxique</span>
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Salut!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Vous trouverez dans la sortie du compilateur l'AST suivant:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    StrLit &quot;Salut!&quot;
```
Ce code contient quatre n≈ìuds. `StmtList` est √† la racine de l'arbre, puis chaque indentation d√©signe que l'on passe √† un n≈ìud enfant, √† un niveau inf√©rieur dans la hi√©rarchie.

`StmtList` est la contraction de _statements list_ qui signifie bloc d'instructions. Il rassemble ensemble toutes les instructions dans le bloc.

Le n≈ìud suivant `Command` indique que l'on utilise une proc√©dure dont le nom est donn√© par son n≈ìud enfant `Ident`. Un `Ident` peut-√™tre le nom d'une variable, d'un objet ou d'une proc√©dure.
Le n≈ìud `Command` pr√©cise la fa√ßon dont la proc√©dure est appel√©e. Je ne d√©taille pas ici, mais cela a un rapport avec l'UFCS: Uniform Function Call Syntax qui est une propri√©t√© du langage qui indique qu'une fonction ou proc√©dure peut √™tre appel√©e indiff√©remment avec trois syntaxes distinctes.

Nous avons ensuite deux n≈ìuds avec du texte accol√© √† la suite. Les n≈ìuds correspondants √† des noms de variables ou de proc√©dures sont des n≈ìuds de type `Ident`.
Les chaines de caract√®res sont des n≈ìuds de type `StrLit`.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Afin de vous donner une id√©e de ce qui se passe en g√©n√©ral, voici un exemple d'un code nettement plus complexe.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># Don't forget to import std/macros!</span>
  <span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]

nbText:<span class="hljs-string">&quot;&quot;&quot;
Ce code donne en sortie l'arbre syntaxique suivant:
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
L'AST retourn√© par `dumpTree` d√©marrera sauf quelques exceptions toujours par `StmtList`.
Les d√©finitions de type se retrouvent toujours dans une `TypeSection` qui poss√®dent autant d'enfants de type `TypeDef` que de d√©finitions.
Les types objets sont d√©finis par des `ObjectTy`.

Afin de mieux visualiser l'hi√©rarchie, vous trouverez ci-dessous un sch√©ma de l'AST:
&quot;&quot;&quot;</span>

nbImage(url=<span class="hljs-string">&quot;pictures/ASTtree.jpg&quot;</span>, caption=<span class="hljs-string">&quot;Arbre syntaxique de la d√©finition du type myObject&quot;</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
Il n'est pas n√©cessaire que vous compreniez l'ensemble de la g√©n√©ration de l'AST. Sachez simplement que vous pouvez l'obtenir avec la commande `DumpTree`.
Si jamais vous avez besoin d'√©crire vous m√™me un AST pour une macro, sachez que des exemples pour toutes les structures et mots-clefs sont dans la documentation des macros:
[std/macros](https://nim-lang.org/docs/macros.html)
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Premier exemple de Macro: multiplication par deux
La premi√®re macro que je vous pr√©sente provient de cette [vid√©o Youtube](https://www.youtube.com/watch?v=WHyOHQ_GkNo) r√©alis√©e par [Jeff Delaunay sur sa cha√Æne Fireship](https://www.youtube.com/c/Fireship).

Lorsque un utilisateur d√©sire afficher des valeurs enti√®res sous cette macro, les valeurs seront multipli√©es par deux.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>
  timesTwo:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Avant d'expliciter le fonctionnement de la macro, on va comparer l'AST du code donn√© en entr√©e,
avec celui que l'on pense obtenir avec le code:
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">4</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">6</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Le compilateur retourne:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 3
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```
Cette sortie ressemble √† s'y m√©prendre au premier exemple d'AST vu pr√©c√©demment.
Au lieu du StrLit &quot;Salut!&quot;, on a d√©sormais IntLit suivi du nombre pr√©sent dans le code source ou dans la sortie.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
```

`StmtList` stands for *statements list*. It groups together all the instructions in your block.

The `Command` node indicates that you use a function whose name is given by its child `Ident` node. An `Ident` can be any variable, object, procedure name.

Our integer literal whose value is 1 has the node kind `IntLit`.

Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code `1 echo` which does not compile.
```nim
StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
```

`StmtList`, `Command`, `IntLit` and `Ident` are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix `nnk`, e.g. `nnkIdent`.
You can get the full list of node kinds [at the std/macros source code](https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89).
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">macro</span> timesTwoAndEcho(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> repr <span class="hljs-literal">result</span>

  timesTwoAndEcho:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
The output of a macro is an AST, and we can try to write it for a few examples:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```
Please note that line breaks are not part of the Nim's AST!

Here, the output AST is almost the same as the input. We only change the integer literal value.

Our root node in the input AST is a statement list.
To fetch the `Command` children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write `statements[0]`.
To loop over all the child nodes, one can use a `for statement in statements` loop.

We need to fetch the nodes under a `Command` instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to `nnkIntLit`. We get their value with the attribute `node.intVal`.
&quot;&quot;&quot;</span>


nbText:<span class="hljs-string">&quot;&quot;&quot;
I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with [some rules](https://en.wikipedia.org/wiki/Data_structure_alignment).

It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.

We can pack a structure with the pragma `{.packed.}`, which removes this extra space. This has the disadvantage to slow down memory accesses.

We would like to detect the presence of holes in an object.

The first step is to look at the AST of the input code we want to parse.

One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;

&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
```nim
typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
```

Type with pragmas aren't supported yet
```nim


when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro does always the same steps:

  1. Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.
  2. Fetch properties of the selected node.
  3. Form AST output in function of these input node's properties.
  4. Continue exploring the AST.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Your macros will require a long docstring and many comments both with thorough details.

I present now my macro `typeMemoryRepr` inspired from the [nim memory guide](https://zevv.nl/nim-memory/) on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.

```nim
type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
```

All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.

I have split this macro into different procedures.
The `echoSizeVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return the code:
```nim
echo a.field.sizeof
```
We create a NimNode of kind `StmtList` (a statement list), that contains `IdentNode`s.
The first `IdentNode` is the command `echo`.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a `nnkDotExpr`.

It suffices to output the above code under a `dumpTree` block, to understand the AST we have to generate.
```nim
dumpTree:
  echo a.field.sizeof
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
    newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(variable),
                  newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              ))

nbText:<span class="hljs-string">&quot;&quot;&quot;
The `echoAddressVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return its address:
```nim
echo a.field.addr.repr
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
    newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(variable),
                      newIdentNode(nameOfField)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                ))


nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
    <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
    <span class="hljs-comment">## * initializes a variable of this type</span>
    <span class="hljs-comment">## * echoes the size and address of the variable</span>
    <span class="hljs-comment">## Then, for each field:</span>
    <span class="hljs-comment">## * echoes the size and address of the variable field</span>

    <span class="hljs-comment"># We begin by running the type definition.</span>
    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`

    <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
    <span class="hljs-comment"># We create the output's AST along parsing.</span>
    <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-comment"># We select only the type section in the StmtList</span>
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-comment">## Generation of AST:</span>
            <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
            )
            <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
              <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr

nbCode:
  typeMemoryRepr:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).

There is actually already a function to do so and this will be the object of a future release of this tutorial.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
The following macro enables to create enums with power of two values.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/[enumerate, math]

nbCode:
  <span class="hljs-comment"># jmgomez on Discord</span>
  <span class="hljs-keyword">macro</span> power2Enum(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">let</span> srcFields = body[^<span class="hljs-number">1</span>][<span class="hljs-number">1.</span>.^<span class="hljs-number">1</span>]
    <span class="hljs-keyword">var</span> dstFields =  nnkEnumTy.newTree(newEmptyNode())
    <span class="hljs-keyword">for</span> idx, field <span class="hljs-keyword">in</span> enumerate(srcFields):
      dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(<span class="hljs-number">2.0</span>, idx.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">int</span>))

    body[^<span class="hljs-number">1</span>] = dstFields
    <span class="hljs-keyword">echo</span> repr body
    body


  <span class="hljs-keyword">type</span> <span class="hljs-type">Test</span> {.power2Enum.}  = <span class="hljs-keyword">enum</span>
    a, b, c, d

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro is not always the best alternative. A simple set and a cast gives the same result.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># Rika</span>
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Setting</span> = <span class="hljs-keyword">enum</span>
      a, b, c
    <span class="hljs-type">Settings</span> = <span class="hljs-built_in">set</span>[<span class="hljs-type">Setting</span>]
  <span class="hljs-keyword">let</span> settings: <span class="hljs-type">Settings</span> = {a, c}
  <span class="hljs-keyword">echo</span> <span class="hljs-keyword">cast</span>[<span class="hljs-built_in">uint8</span>](settings)

nbSection <span class="hljs-string">&quot;References and Bibliography&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Press `Ctrl` + `Click` to open following links in a new tab.

First, there are four official resources at the Nim's website:
  1. [Nim by Example](https://nim-by-example.github.io/macros/)
  2. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
  3. [Manual section about macros](https://nim-lang.org/docs/manual.html#macros)
  4. [The Standard Documentation of the std/macros library](https://nim-lang.org/docs/macros.html)
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.

Many developers have written their macro's tutorial:
  1. [Nim in Y minutes](https://learnxinyminutes.com/docs/nim/)
  2. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  3. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  4. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  5. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

There are plentiful of posts in the forum that are good references:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. [Fast array assignment](https://forum.nim-lang.org/t/10037)
  5. [Variable injection](https://forum.nim-lang.org/t/10513)
  6. [Proc inspection](https://forum.nim-lang.org/t/9127)
  7. etc ‚Ä¶ Please use the forum search bar with specific keywords like `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Last but no least, there are three Nim books:
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX).
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

We can also count many projects that are macro- or template-based:
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. My favorite DSL : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
  [mratsim](https://github.com/mratsim/) develops this library, and made [a list of all his DSL](https://forum.nim-lang.org/t/9551#62851) in the forum.
  3. [Jester](https://github.com/dom96/jester) library is a HTML DSL, where each block defines a route in your web application.
  4. [nimib](https://pietroppeter.github.io/nimib/) with which this blog post has been written.
  5. [Nim4UE](https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.
&quot;&quot;&quot;</span>
nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>