<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>index.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>index.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1>Nim Metaprogramming (Macros) Tutorial</h1>
<p>This tutorial aims to be a step-by-step introduction to the metaprogramming features of the Nim Language.
There are already many resources on the Web, but I strive to provide more thorough details on the development process all in one place.</p>
<h2>Existing resources</h2>
<p>Press <code>Ctrl</code> + <code>Click</code> to open following links in a new tab.</p>
<p>First, there are three official resources at the Nim's website:</p>
<ol>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Manual section about macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">The Standard Documentation of the std/macros library</a>
The 1. and 2. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference.</li>
</ol>
<p>Many developers have written their macro's tutorial:</p>
<ol>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>There are plentiful of posts in the forum that are good references:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li>etc ‚Ä¶ Please use the forum search bar with keywords like <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Last but no least, there are three Nim books:</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>. (This link is NOT affiliated)</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>We can also count many projects that are macro- or template-based:</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>My favorite macro : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a>
Do not just look at the header of procedures to determine if it is a macro or not. Often a macro relies on a lot of smaller procedures.</p>
</li>
</ol>
<h2>Introduction</h2>
<p>There are four kind/levels of procedures:</p>
<ol>
<li>ordinary proc/iterator</li>
<li>generic proc/iterator</li>
<li>template</li>
<li>macro
The higher the number, the more meta we get. It is recommended to program one's procedure with the lowest level of metaprogramming possible.</li>
</ol>
<p>Let us start with <code>template</code>s and <code>untyped</code> parameters. I do not <code>present</code> generics in this tutorial.</p>
<h2>Templates</h2>
<p>We can see <em>templates</em> as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : <code>untyped</code>.
For those familiar with <a href="https://gcc.gnu.org/onlinedocs/cpp/">preprocessing</a> in the C family of languages (C, C++, C#), it does the same than the <code>#define</code> or <code>#if</code>, <code>#endif</code> macros and much more.</p>
<p>Nim's language defines boolean operator like <code>!=</code> with templates. You can even look at Nim's source code, that's almost the same code. See the <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">documentation</a>.</p>
<pre><code class="nim hljs"><span class="hljs-comment">## Example from std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)</code></pre>
<p>We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the <code>duplicate</code> template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements
  statements

duplicate:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre><samp>5
5</samp></pre>
<pre><code class="nim hljs"><span class="hljs-comment">## Example from Nim In Action</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
<span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
    statements

repeat <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)</code></pre><pre><samp>Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!</samp></pre>
<p>In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a <code>doWhile</code> construct.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">proc</span> nextSyracuseTerm(term: <span class="hljs-keyword">var</span> <span class="hljs-built_in">int</span>) =
  <span class="hljs-comment">## This sequence should resolve to the cyclic sequence 1, 4, 2, 1, ...</span>
  <span class="hljs-keyword">if</span> term <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
    term *= <span class="hljs-number">3</span>
    term.inc
  <span class="hljs-keyword">else</span>:
    term = term <span class="hljs-keyword">div</span> <span class="hljs-number">2</span>

<span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> myInt = <span class="hljs-number">5</span>
doWhile myInt &gt;= <span class="hljs-number">6</span>:
    <span class="hljs-keyword">echo</span> myInt
    nextSyracuseTerm(myInt)</code></pre><pre><samp>5
16
8</samp></pre>
<p>Notice though that the end result is fairly different than C++ code</p>
<pre><code class="language-cpp">int i = 0;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
</code></pre>
<p>The instructions and the conditional appear before the <code>while</code> whereas this doWhile Nim construct will have the conditional after the <code>doWhile</code>:</p>
<pre><code class="language-nim">var i: int = 0 # superfluous type annotation
doWhile i &lt; 10:
  echo &quot;Hello World!&quot;
  i.inc
</code></pre>
<p>Though powerful, templates are still limited. As an example, I didn't achieve to make a discard template (that ta disabling a code.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">template</span> `<span class="hljs-keyword">discard</span>`(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">discard</span> <span class="hljs-literal">nil</span> <span class="hljs-comment"># Cheat here</span>

`<span class="hljs-keyword">discard</span>`:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Test the discard template, if you see this message, it has failed. If not, well ‚Ä¶&quot;</span></code></pre>
<h2>Macros</h2>
<p>Macros can be seen as an empowered template procedure.
Instead of simply taking untyped blocks and reuse them as lego bricks to return a code, we can parse our untyped parameter and do something conditionally to informations given in these parameters.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">macro</span> discard2(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()
discard2:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not discard me, you'll never get out!&quot;</span></code></pre>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST) (refer to the <a href="">manual AST section</a></p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<pre><code class="language-raw">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory.
We should be able in the future to automatically swap the fields to remove the holes (or at least propose a fixed type).
The first step is to look at the AST of the input code we want to parse.</p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<p>It is not easy (if even possible) to list all the possible types.
By adding some other informations we get a better picture of the general AST of a type.</p>
<pre><code class="nim hljs">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<p>A macro does three steps in this order:
0. Check that the node is of the expected kind.</p>
<ol>
<li>Get properties of the input AST node (Maybe by going through node child's Ident).</li>
<li>Form AST output in function of these input node's properties.</li>
<li>Go through the node's child.</li>
</ol>
<p>A good macro is necessary complex enough to require a long docstring with thorough details.
We begin by running the type definition.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
  <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
  <span class="hljs-comment">## * initializes a variable of this type</span>
  <span class="hljs-comment">## * echoes the size of the variable</span>
  <span class="hljs-comment">## * echoes the address of the variable</span>
  <span class="hljs-comment">## Then, for each field:</span>
  <span class="hljs-comment">## * echoes the size of the variable field</span>
  <span class="hljs-comment">## * echoes the address of the variable field</span>

  <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`
  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-comment">## Generation of AST:</span>
          <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
          quote <span class="hljs-keyword">do</span>:
            <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate type defined in typedef</span>
            <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
            <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
          )
          <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(nameOfTestVariable),
                  newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal) <span class="hljs-comment"># The name of the field is the first ident</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              )))
            <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>

            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(nameOfTestVariable),
                    newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              )))
  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr

<span class="hljs-keyword">when</span> isMainModule:
  typeMemoryRepr:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">uint64</span>
        c: <span class="hljs-built_in">char</span>
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing2</span> = <span class="hljs-keyword">object</span>
        oneChar: <span class="hljs-built_in">char</span>
        myStr: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">when</span> <span class="hljs-literal">false</span>: <span class="hljs-comment"># erroneous code</span>
    <span class="hljs-comment"># type with pragmas aren't supported yet</span>
    typeMemoryRepr:
      <span class="hljs-keyword">type</span>
        <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span>
          oneChar: <span class="hljs-built_in">char</span>
          myStr: <span class="hljs-built_in">string</span></code></pre><pre><samp>32
ptr Thing(a: 0.0, b: 0, c: '\0')
4
ptr 0.0
8
ptr 0
1
ptr '\0'
24
ptr Thing2(oneChar: '\0', myStr: &quot;&quot;)
1
ptr '\0'
16
ptr &quot;&quot;</samp></pre>
</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> strformat, strutils
<span class="hljs-keyword">import</span> nimib

nbInit

<span class="hljs-keyword">import</span> std/[macros]
nbText: <span class="hljs-string">&quot;&quot;&quot;
# Nim Metaprogramming (Macros) Tutorial
This tutorial aims to be a step-by-step introduction to the metaprogramming features of the Nim Language.
There are already many resources on the Web, but I strive to provide more thorough details on the development process all in one place.

## Existing resources
Press `Ctrl` + `Click` to open following links in a new tab.

First, there are three official resources at the Nim's website:
  1. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
  2. [Manual section about macros](https://nim-lang.org/docs/manual.html#macros)
  3. [The Standard Documentation of the std/macros library](https://nim-lang.org/docs/macros.html)
The 1. and 2. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference.

Many developers have written their macro's tutorial:
  1. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  2. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  3. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  4. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

There are plentiful of posts in the forum that are good references:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. etc ‚Ä¶ Please use the forum search bar with keywords like `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Last but no least, there are three Nim books:
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX). (This link is NOT affiliated)
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

We can also count many projects that are macro- or template-based:
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. My favorite macro : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
Do not just look at the header of procedures to determine if it is a macro or not. Often a macro relies on a lot of smaller procedures.

## Introduction
There are four kind/levels of procedures:
  1. ordinary proc/iterator
  2. generic proc/iterator
  3. template
  4. macro
The higher the number, the more meta we get. It is recommended to program one's procedure with the lowest level of metaprogramming possible. 
Let us start with `template`s and `untyped` parameters. I do not `present` generics in this tutorial.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
## Templates
We can see *templates* as procedures that modify code through a copy-paste mechanism. Pieces of code are given to (and outputted by) the template with a special type : `untyped`. 
For those familiar with [preprocessing](https://gcc.gnu.org/onlinedocs/cpp/) in the C family of languages (C, C++, C#), it does the same than the `#define` or `#if`, `#endif` macros and much more.
&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Nim's language defines boolean operator like `!=` with templates. You can even look at Nim's source code, that's almost the same code. See the [documentation](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">## Example from std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the `duplicate` template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements
    statements

  duplicate:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbCode:
  <span class="hljs-comment">## Example from Nim In Action</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
  <span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
      statements

  repeat <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a `doWhile` construct.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> nextSyracuseTerm(term: <span class="hljs-keyword">var</span> <span class="hljs-built_in">int</span>) =
    <span class="hljs-comment">## This sequence should resolve to the cyclic sequence 1, 4, 2, 1, ...</span>
    <span class="hljs-keyword">if</span> term <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
      term *= <span class="hljs-number">3</span>
      term.inc
    <span class="hljs-keyword">else</span>:
      term = term <span class="hljs-keyword">div</span> <span class="hljs-number">2</span>

  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop
  
  <span class="hljs-keyword">var</span> myInt = <span class="hljs-number">5</span>
  doWhile myInt &gt;= <span class="hljs-number">6</span>:
      <span class="hljs-keyword">echo</span> myInt
      nextSyracuseTerm(myInt)

nbText:<span class="hljs-string">&quot;&quot;&quot;
Notice though that the end result is fairly different than C++ code
```cpp
int i = 0;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
```
The instructions and the conditional appear before the `while` whereas this doWhile Nim construct will have the conditional after the `doWhile`:
```nim
var i: int = 0 # superfluous type annotation
doWhile i &lt; 10:
  echo &quot;Hello World!&quot;
  i.inc
```
&quot;&quot;&quot;</span>
  
nbText:<span class="hljs-string">&quot;&quot;&quot;
Though powerful, templates are still limited. As an example, I didn't achieve to make a discard template (that ta disabling a code.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> `<span class="hljs-keyword">discard</span>`(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">discard</span> <span class="hljs-literal">nil</span> <span class="hljs-comment"># Cheat here</span>

  `<span class="hljs-keyword">discard</span>`:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Test the discard template, if you see this message, it has failed. If not, well ‚Ä¶&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
## Macros
Macros can be seen as an empowered template procedure.
Instead of simply taking untyped blocks and reuse them as lego bricks to return a code, we can parse our untyped parameter and do something conditionally to informations given in these parameters.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">macro</span> discard2(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()
  discard2:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not discard me, you'll never get out!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST) (refer to the [manual AST section]()
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]
nbText:<span class="hljs-string">&quot;&quot;&quot;
```raw
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory.
We should be able in the future to automatically swap the fields to remove the holes (or at least propose a fixed type).
The first step is to look at the AST of the input code we want to parse.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
It is not easy (if even possible) to list all the possible types.
By adding some other informations we get a better picture of the general AST of a type.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro does three steps in this order:
  0. Check that the node is of the expected kind.
  1. Get properties of the input AST node (Maybe by going through node child's Ident).
  2. Form AST output in function of these input node's properties.
  3. Go through the node's child.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A good macro is necessary complex enough to require a long docstring with thorough details.
We begin by running the type definition.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
    <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
    <span class="hljs-comment">## * initializes a variable of this type</span>
    <span class="hljs-comment">## * echoes the size of the variable</span>
    <span class="hljs-comment">## * echoes the address of the variable</span>
    <span class="hljs-comment">## Then, for each field:</span>
    <span class="hljs-comment">## * echoes the size of the variable field</span>
    <span class="hljs-comment">## * echoes the address of the variable field</span>

    <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`
    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-comment">## Generation of AST:</span>
            <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate type defined in typedef</span>
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
            )
            <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(nameOfTestVariable),
                    newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal) <span class="hljs-comment"># The name of the field is the first ident</span>
                    ),
                    newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
                )
                )))
              <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>

              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(nameOfTestVariable),
                      newIdentNode(tnode[i][<span class="hljs-number">0</span>].strVal)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                )))
    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr

  <span class="hljs-keyword">when</span> isMainModule:
    typeMemoryRepr:
      <span class="hljs-keyword">type</span>
        <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
          a: <span class="hljs-built_in">float32</span>
          b: <span class="hljs-built_in">uint64</span>
          c: <span class="hljs-built_in">char</span>
      <span class="hljs-keyword">type</span>
        <span class="hljs-type">Thing2</span> = <span class="hljs-keyword">object</span>
          oneChar: <span class="hljs-built_in">char</span>
          myStr: <span class="hljs-built_in">string</span>
    <span class="hljs-keyword">when</span> <span class="hljs-literal">false</span>: <span class="hljs-comment"># erroneous code</span>
      <span class="hljs-comment"># type with pragmas aren't supported yet</span>
      typeMemoryRepr:
        <span class="hljs-keyword">type</span>
          <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span>
            oneChar: <span class="hljs-built_in">char</span>
            myStr: <span class="hljs-built_in">string</span>
nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>